1. 创建一个形状为 (3,4,5) 的数组，数据类型是64位的小数，然后输出阵列的以下属性

    维数
    形状
    元素总数
    元素的数据类型
    每个元素所佔用的内存大小
    所有元素所佔用的内存大小


2. 尝试把嵌套的python列表转换成numpy阵列，然后把numpy阵列转换成python列表


3. 按以下要求操练
    1. 创建一个形状为 (3,3)的阵列，值全为1
    2. 创建一个形状为 (3,3)的阵列，值全为0
    3. 创建一个形状为 (3,3)的阵列，不初始化值
    4. 给定一个阵列a如下
        array([[ 0,  1,  2,  3],
               [ 4,  5,  6,  7],
               [ 8,  9, 10, 11]])
        创建一个形状相同，数据类型为8位无符号整型的阵列，元素值全为101


4. 创建一个阵列，包含N 个小数，最小值是0, 最大值是1, 相邻元素之间的差是0.1


5. 创建一个阵列，包含-π 到 +π 之间的1000个小数，最大值是 +π


6. 按以下要求创建阵列
    1. 把元素全部为整数的嵌套的Python列表转换成numpy阵列
    2. 创建一个形状为(2,3)，全部元素的值都为0的阵列 (np.zeros)
    3. 创建一个形状为(2,3)，全部元素的值都为1的阵列 (np.ones)
    4. 创建一个形状为(2,3)，全部元素的值都为0.1的阵列 (np.full)
    5. 创建一个形状为(2,3)的阵列，不初始化阵列的值 (np.empty)
    6. 创建一个形状与已有阵列相同的阵列，并把值初始化为0 (np.zeros_like)
    7. 创建一个形状与已有阵列相同的阵列，并把值初始化为1 (np.ones_like)
    8. 创建一个形状与已有阵列相同的阵列，并把值初始化为0.1 (np.full_like)
    9. 创建一个形状与已有阵列相同的阵列，不对值做初始化 (np.empty_like)
    10. 创建一个一维阵列，值是0到1之间的小数，间隔是0.1 (np.arange)
    11. 创建一个一维阵列，值是0到1之间的小数，元素总数是20个 (np.linspace)
    12. 创建一个一维阵列，值是0到1之间的小数，元素总数是20个，不包含结束点的值 (endpoint=False)
    13. 创建一个形状为(3,3,3)的阵列，用随机数填充，随机数是[0, 1) 范围的均匀分布 (np.random.rand)
    14. 创建一个形状为(3,3,3)的阵列，用随机数填充，随机数符合均值为0方差为1的常态分布 (np.random.randn)


7. 按以下要求操作
    1. 创建一个形状为(2,2,2,2,2,2,2,2,2,2)的包含10个轴的阵列，值为从0开始递增的整数
    2. 在交互式界面打印阵列内容，做以下观察：
        1. 最后一个轴的打印方向
        2. 其它轴的打印方向
        3. 空行的使用规律
    3. 创建一个包含1万个整数的一维阵列
    4. 在交互式界面打印阵列内容，观察是否能够打印出全部的元素
    5. 设定打印选项(np.set_printoptions)中的threshold值为1万，观察是否能够打印出全部的元素
    6. 设定打印选项(np.set_printoptions)中的threshold值为9999，观察是否能够打印出全部的元素
    7. 设定打印选项(np.set_printoptions)中的threshold值为np.nan，观察是否能够打印出全部的元素
    8. 创建一个包含21个整数形状为(3,7)的阵列
    9. 设定打印选项(np.set_printoptions)中的threshold值为21，观察是否能够打印出全部的元素
    10. 设定打印选项(np.set_printoptions)中的threshold值为20，观察是否能够打印出全部的元素


8. 按以下要求操作
    1. 用以下命令创建一个形状为(4,4,4)的阵列
        a = np.random.randint(0,10,(4,4,4))
    2. 执行阵列a的sum方法，不加任何参数，观察输出
    3. 执行阵列a的sum方法三次，分别加上参数axis=0, axis=1, axis=2，观察输出，尝试理解numpy的内部操作
    4. 按照同样的方式操练阵列a的max, min, mean这三个方法


9. 按以下要求操练
    1. 创建一个形状为(3,3,3)的阵列，用随机数填充
    2. 获取阵列坐标(2,2)位置的值
    3. 获取阵列第一维的第二个元素
    4. 获取阵列第二维的第二个元素
    5. 获取阵列第一维的第二个元素中的第二个元素
    6. 获取阵列最高维的最后一个元素
    7. 用for循环迭代阵列的第一维元素，打印出每个元素
    8. 用for循环迭代打印出阵列的每一个元素


10. 按以下要求操练
    1. 创建阵列a，形状为(2,3,4)，内容为连续的整数
    2. 从阵列a生成一个一维阵列
    3. 从阵列a生成一个形状为(4,6)的阵列
    4. 从阵列a生成一个新阵列，轴的数量是3, 轴0轴1的长度分别是2和6,轴2让numpy自动检测
    5. 从阵列a生成一个形状为(4,7)的阵列，观察出错信息
    6. 从阵列a生成一个形状为(4,5)的阵列，使用np.resize函数
    7. 对比a.shape和a.T.shape，观察规律
    8. 手动对一个二维阵列做转置操作
        1. 创建一个二维阵列: a = np.arange(6).reshape(2,3)
        2. 创建另外一个阵列，形状是a颠倒形状: b = np.zeros(a.shape[::-1])
        3. 用阵列a的值赋值给阵列b
            b[0] = a[:,0]
            b[1] = a[:,1]
            b[2] = a[:,2]
        4. 验证阵列b的值与a.T 完全相等: np.all(b == a.T)


11. 按以下要求操练
    1. 创建两个阵列:
        a = np.arange(6).reshape(2,3)
        b = np.arange(1,7).reshape(2,3)
    2. 运行以下命令，查看输出，尝试理解numpy的内部操作：
        np.vstack([a,b])
        np.hstack([a,b])
    3. 再创建两个阵列:
        a = np.arange(24).reshape(2,3,4)
        b = np.arange(1,25).reshape(2,3,4)
    4. 运行以下命令，查看输出，尝试理解numpy的内部操作：
        np.vstack([a,b])
        np.hstack([a,b])
        np.dstack([a,b])
    5. 用np.concatenate重复效果等同于上一步的操作
        np.concatenate([a,b], axis=0)   # vstack
        np.concatenate([a,b], axis=1)   # hstack
        np.concatenate([a,b], axis=2)   # dstack
    6. 运行以下命令，比较其输出与上一步的区别
        np.stack([a,b], axis=0)
        np.stack([a,b], axis=1)
        np.stack([a,b], axis=2)

12. 按以下要求操练
    1. 创建阵列: a = np.arange(64).reshape(8,8)
    2. 把阵列按0轴平均分为四份: np.split(a, 4)
    3. 把阵列按1轴平均分为四份: np.split(a, 4, axis=1)
    4. 把阵列按0轴平均分为三份，看错误信息
    5. 把阵列按0轴的3和5两个索引点分为三份: np.split(a, [3,5])
    6. 把阵列按0轴近似平均地分为三份: np.array_split(a, 3)
    7. 创建一个(2,2,2)的阵列，填充连续整数
        1. a = np.arange(8).reshape(2,2,2)
        2. 运行以下命令，观察输出
            np.vsplit(a, 2)
            np.hsplit(a, 2)
            np.dsplit(a, 2)


13. 按以下要求操练
    1. 创建一个一维阵列: a = np.arange(12)
    2. 把阵列a 改变形状生成一个二维阵列: b = a.reshape((3,4))
    3. 查看阵列a和b的标记，观察其中的 OWNDATA 的值
        a.flags
        b.flags
    4. 运行以下命令并观察输出
        b.base is a
        a.base is None
    5. 从阵列a创建一个浅副本，并运行相关测试命令，观察输出
        c = a.view()
        c.flags
        c.base is b.base is a
    6. 从阵列b创建一个深副本，并运行相关测试命令，观察输出
        d = b.copy()
        d.flags
        d.base is None
    7. 运行以下命令查看a,b,c,d四个阵列的数据的内存地址
        a.__array_interface__['data'][0]
        b.__array_interface__['data'][0]
        c.__array_interface__['data'][0]
        d.__array_interface__['data'][0]
    8. 共享相同数据的不同阵列，其形状互相独立，运行以下命令，观察输出
        b.base is c.base is a
        a.shape
        b.shape
        c.shape
    9. 对阵列做切片将生成视图，运行以下命令，观察输出
        a.flags.owndata
        a[:].flags.owndata
    10. a,b,c共享相同的数据，d有独立的数据，修改阵列c的某个值，观察阵列a,b,c,d的值的变化
        c[-1] = 9999
        a
        b
        c
        d
    11. ravel视情况生成深副本或浅副本，flatten总是生成深副本，运行以下命令，观察输出
        d.flags.c_contiguous
        d.ravel(order='C').flags.owndata
        d.ravel(order='F').flags.owndata
        d.flatten(order='C').flags.owndata
        d.flatten(order='F').flags.owndata


14. 按以下要求操练
    1. 创建两个阵列
        a = np.arange(3)
        b = np.arange(4)
    2. 执行以下操作，观察输出
        a + b
        a[:,None].shape
        b[:,None].shape
        b[None,:].shape
        a[:,None] + b
        a + b[:,None]
        a[:,None] + b[None,:]
        a + 1 == a + np.full_like(a, 1)


15. 按以下要求操练
    1. 创建阵列:
        a = np.arange(10,0,-1)
        b = np.arange(48).reshape(3,4,4)
    2. 阵列索引生成的是深副本: a[[0,1,2]].flags.owndata
    3. 结果阵列的数据类型来自原阵列: a[[0,1,2]].dtype == a.dtype
    4. 结果阵列的形状是索引阵列的形状串接上未指明的剩余的轴的形状:
        a[[0,1,2]].shape == (3,)
        idx = np.array([[0,1],[2,1]])
        b.shape, b[idx].shape
    5. 运行以下命令，观察输出
        a[[0,1,101]]
    6. 多个阵列对应位置的值组合成索引，运行以下命令，观察输出
        b[[0,1],[0,1],[0,1]]
        b[[0,1],[0,1]]
    7. 当阵列后面有数字时，数字将被广播成与前面的阵列相同的形状
        b[[0,1],2]
    8. 当两个阵列形状不同时，也尝试广播，无法广播时将出错
        b[[0,1],[[1,2],[2,3]]]      <-- (2,)与(2,2)正常广播
        b[[0,1,2],[[1,2],[2,3]]]    <-- (3,)与(2,2)无法兼容广播，出错
    9. 索引阵列/切片前面的数据用于按轴的顺序选出指定的数据，供后面的切片/索引阵列索引
        b[0,1,[1,3]]
        b[0,1,::2]
    10. 切片与右边的数字广播时，切片被转成一维阵列，然后再广播
        b[::2,0]
    11. 切片与切片/阵列广播时，所有切片被转成一维阵列，然后左边的转成(X,1)的形状，右边的转成(1,X)的形状，然后广播
        b[:2,:3]
        b[:2,[0,2]]
        b[[0,2],:2]
    12. 用能够被转换成阵列的其它数据类型，作用等同于np.array
        a[np.array([0,1,2])]
        a[[0,1,2]]
    13. 但是python的tuple是直接作为索引的，不会被转换成ndarray
        b[(0,1,2)]      # 等价于 b[0,1,2]
        b[np.array((0,1,2))]
    14. 用bool阵列来索引
        idx = a > 5         # 创建bool阵列
        idx.shape, a.shape  # 形状相同
        a[idx]
        b[np.array([True, False, False])]   # 手动创建bool阵列
        idx = np.full(b.shape[:2], False, dtype=bool)
        idx.shape, b.shape      # bool阵列形状与b阵列头部相同
        idx[:,0] = True
        b[idx]
    15. 对索引结果赋值，用来赋值的值与索引结果的形状必须相同或者兼容广播
        b[[0,2],[0,1]]
        b[[0,2],[0,1]].shape
        b[[0,2],[0,1]] = 0                      # 正常广播
        b[[0,2],[0,1]] = [1,2,3,4]              # 正常广播
        b[[0,2],[0,1]] = [[1,2,3,4],[2,3,4,4]]  # 匹配，不需广播
        b[[0,2],[0,1]] = [1,2]                  # 不能广播，出错


16. 按以下要求操练
    1. 创建结构化阵列的数据类型
        dt = np.dtype([('shape', np.float64, 3),('weight', np.float64, 1)])
    2. 创建结构化阵列
        n = 100
        info = np.zeros(n, dtype=dt)
    3. 获取结构化阵列的记录和列
        info[0]
        info[1]
        info[:2]
        info['shape']
        info['weight']
    4. 修改结构化阵列的数据
        info['shape'] = np.random.randint(1,10,(n,3))
        info['weight'] = np.random.randint(50,100,n)
        info[0]['shape'] = 1,2,3
        info[0]['weight'] = 30


17. 按要求计算
    1. 计算抛3个骰子所得点数之和的可能值
    2. 用numpy计算，不用python的循环
    3. 取出出现频率最高的4种和

    n = np.arange(1,7)
    sums = n[:,None,None] + n[None,:,None] + n[None,None,:]
    counts, bins = np.histogram(sums.flat, np.arange(3,19))
    bins[counts.argsort()[::-1][:4]]

    # vals, counts = np.unique(sums, return_counts=True)
    # vals[(-counts).argsort()[:4]]


18. 操練numpy的IO操作
    1. 保存一個陣列數據到.npy文件中
        np.save('/tmp/arr', a)
    2. 保存多個陣列數據到.npz文件中
        np.savez('/tmp/arr', a=a, b=b)
    3. 從.npy, npz文件中加載陣列
        a = np.load('/tmp/arr.npy')
        f = np.load('/tmp/arr.npz')
        f['a']
        f['b']
    4. 導出陣列到csv文件中
        np.savetxt('/tmp/aa', a, delimiter=',')
    5. 從csv文件導入陣列
        np.genfromtxt('/tmp/aa', delimiter=',')
    6. 導入包含了數字和文本的文件
        np.genfromtxt('/tmp/aa', delimiter=',', dtype='object')
